<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Map Viewer</title>
  <style>
    :root{
      --grid-size: 30px; /* background grid size */
      --control-size: 50px;
      --control-gap: 10px;
      --viewer-max-w: 1024px;
      --viewer-max-h: 768px;
    }

    /* Page baseline */
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background-color: #ffffff;
    }

    /* Viewer keeps a 4:3 ratio, up to 1024x768, but scales down responsively */
    .viewer{
      position:relative;
      width:min(100vw - 24px, var(--viewer-max-w));
      aspect-ratio: 4 / 3;
      max-height:min(100vh - 24px, var(--viewer-max-h));
      overflow:hidden;
    }

    /* Canvas holds the transformed image and the background grid */
    .canvas{
      position:absolute; inset:0;
      overflow:hidden;
      touch-action: none; /* enables custom pan & pinch */
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
      background-image: linear-gradient(to right, #f3e8e3 2px, transparent 2px),
                        linear-gradient(to bottom, #f3e8e3 2px, transparent 2px);
      background-color:#f7efeb;
      background-size: var(--grid-size) var(--grid-size);
    }
    .canvas.grabbing{ cursor: grabbing; }

    /* NEW: wrapper layer that receives the transform and box-shadow */
    .mapLayer{
      position:absolute; top:0; left:0;
      transform-origin: 0 0;
      will-change: transform;
      pointer-events: none; /* gestures handled on .canvas */
      box-shadow: 0 0 10px rgba(0,0,0,.2);
    }

    /* The image itself is “dumb” – it just fills the wrapper */
    #mapImage{
      display:block;
      width:100%;
      height:100%;
      image-rendering: auto;       /* keep default smoothing */
      pointer-events:none;
      user-drag: none; -webkit-user-drag: none;
      -webkit-touch-callout: none;
      box-shadow: none;            /* IMPORTANT: no shadow on the <img> */
    }

    /* Controls: two minimal squares at bottom-right, horizontally aligned */
    .controls{
      position:absolute; bottom:12px; right:12px;
      display:flex; gap: var(--control-gap);
    }
    .ctrl{
      width:var(--control-size); height:var(--control-size);
      background-color: #96135a;
      color: #ffffff;
      border: none;
      display:grid; place-items:center;
      font-size:40px; line-height:0; font-weight:600;
      transition: transform .08s ease;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .ctrl:active{ transform: translateY(1px); }
    .ctrl:disabled{ opacity:.5; pointer-events:none; }
    .visually-hidden{ position:absolute !important; clip: rect(1px, 1px, 1px, 1px); height:1px; width:1px; overflow:hidden; white-space:nowrap; }
  </style>
</head>
<body>
  <div class="viewer" id="viewer" aria-label="Map viewer">
    <div class="canvas" id="canvas" aria-live="polite">
      <!-- NEW wrapper -->
      <div id="mapLayer" class="mapLayer">
        <img id="mapImage" alt="Map" draggable="false" />
      </div>
    </div>

    <!-- Minimal, textless controls -->
    <div class="controls" aria-controls="canvas">
      <button class="ctrl" id="zoomOut" type="button" aria-label="Zoom out" title="Zoom out">
        <span aria-hidden="true">−</span>
      </button>
      <button class="ctrl" id="zoomIn" type="button" aria-label="Zoom in" title="Zoom in">
        <span aria-hidden="true">+</span>
      </button>
    </div>
  </div>

  <script>
  (function(){
    /*** CONFIG ***/
    const ZOOM_LEVELS = [1, 1.5, 2, 2.5, 3]; // locked zoom steps
    const ASSET_DIR = 'maps';                 // folder containing the images
    const ASSET_BASENAME = 'map';             // e.g. map@1x.webp
    const EXT = 'webp';

    /*** STATE ***/
    const viewer = document.getElementById('viewer');
    const canvas = document.getElementById('canvas');
    const layer  = document.getElementById('mapLayer');   // NEW wrapper
    const img    = document.getElementById('mapImage');
    const btnIn  = document.getElementById('zoomIn');
    const btnOut = document.getElementById('zoomOut');

    let baseWidth = 0;   // natural width of the 1x asset (CSS width we lock to)
    let baseHeight = 0;  // natural height of the 1x asset

    let baseScale = 1;     // fitted scale so that 1x fills viewer by contain
    let translate = { x: 0, y: 0 };
    let zoomIndex = 0;     // index into ZOOM_LEVELS

    let assetRatio = 1;    // NEW: 0.5, 1, 1.5, 2, 2.5, 3

    // For interaction
    let isPanning = false;
    let panStart = {x: 0, y: 0};
    let translateStart = {x: 0, y: 0};

    // Pinch state (pointer events)
    const activePointers = new Map(); // id -> {x,y}
    let pinchInitial = null;          // {distance, center:{x,y}, zoomIndex}

    // Asset cache
    const assetCache = new Map(); // key -> HTMLImageElement (preloaded)

    /*** HELPERS ***/
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    function viewport() {
      const r = canvas.getBoundingClientRect();
      return { w: r.width, h: r.height };
    }

    function currentScale(){
      return baseScale * ZOOM_LEVELS[zoomIndex];
    }

    function setTransform(){
      // Apply transform to the wrapper. Compensate for the asset's layout size.
      layer.style.transform =
        `translate(${translate.x}px, ${translate.y}px) scale(${currentScale()/assetRatio})`;
    }

    function computeBaseScale(){
      const vp = viewport();
      baseScale = Math.min(vp.w / baseWidth, vp.h / baseHeight);
    }

    function clampTranslate(){
      const vp = viewport();
      const scaledW = baseWidth  * currentScale();
      const scaledH = baseHeight * currentScale();

      const minX = Math.min(0, vp.w - scaledW);
      const minY = Math.min(0, vp.h - scaledH);

      if (scaledW <= vp.w) {
        translate.x = (vp.w - scaledW) / 2; // center horizontally
      } else {
        translate.x = clamp(translate.x, minX, 0);
      }

      if (scaledH <= vp.h) {
        translate.y = (vp.h - scaledH) / 2; // center vertically
      } else {
        translate.y = clamp(translate.y, minY, 0);
      }
    }

    function assetKeyFor(zoomIdx){
      // Decide which image asset to use for a given zoom index, with a small-viewport override.
      const vp = viewport();
      const zoomFactor = ZOOM_LEVELS[zoomIdx];

      // If the viewer is narrower than 512px and we're at the base zoom (1x), prefer the 0.5x asset.
      if (vp.w < 512 && zoomFactor <= 1) {
        return '0.5x';
      }
      return `${zoomFactor}x`;
    }

    function assetUrl(key){
      return `${ASSET_DIR}/${ASSET_BASENAME}@${key}.${EXT}`;
    }

    function ensurePreloaded(key){
      if (assetCache.has(key)) return;
      const im = new Image();
      im.decoding = 'async';
      im.src = assetUrl(key);
      assetCache.set(key, im);
    }

    function switchAssetIfNeeded(){
      const key = assetKeyFor(zoomIndex); // e.g. '3x', '2x', '1.5x', '0.5x'
      ensurePreloaded(key);

      // Update the image source
      const cached = assetCache.get(key);
      img.src = (cached && cached.complete) ? cached.src : assetUrl(key);

      // Grow/shrink the wrapper to match the asset's native pixels
      assetRatio = parseFloat(key) || 1;
      layer.style.width  = (baseWidth  * assetRatio) + 'px';
      layer.style.height = (baseHeight * assetRatio) + 'px';

      // Preload neighbors
      if (zoomIndex + 1 < ZOOM_LEVELS.length) ensurePreloaded(assetKeyFor(zoomIndex + 1));
      if (zoomIndex - 1 >= 0) ensurePreloaded(assetKeyFor(zoomIndex - 1));

      // Re-apply transform so the on-screen size remains consistent
      setTransform();
    }

    function updateButtons(){
      btnOut.disabled = (zoomIndex === 0);
      btnIn.disabled  = (zoomIndex === ZOOM_LEVELS.length - 1);
    }

    function setZoomIndex(newIndex){
      newIndex = clamp(newIndex, 0, ZOOM_LEVELS.length - 1);
      const vp = viewport();

      // Keep the current view center stable while zooming
      const s1 = currentScale();
      const viewPoint = { x: vp.w/2, y: vp.h/2 };
      const imagePoint = { // convert from view-space to image-space (pre-transform)
        x: (viewPoint.x - translate.x) / s1,
        y: (viewPoint.y - translate.y) / s1
      };

      // Apply zoom change
      zoomIndex = newIndex;

      const s2 = currentScale();
      // Recompute translate to keep imagePoint under the same view center
      translate.x = viewPoint.x - imagePoint.x * s2;
      translate.y = viewPoint.y - imagePoint.y * s2;

      clampTranslate();
      switchAssetIfNeeded(); // may change assetRatio
      setTransform();
      updateButtons();
    }

    function zoomIn(){ setZoomIndex(zoomIndex + 1); }
    function zoomOut(){ setZoomIndex(zoomIndex - 1); }

    /*** UI HOOKUPS ***/
    btnIn.addEventListener('click', zoomIn);
    btnOut.addEventListener('click', zoomOut);

    // Wheel to zoom (no modifiers)
    canvas.addEventListener('wheel', (e)=>{
      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) return;
      e.preventDefault();
      if (e.deltaY < 0) zoomIn(); else zoomOut();
    }, { passive: false });

    // Panning via pointer events
    canvas.addEventListener('pointerdown', (e)=>{
      // ignore if a second pointer is starting (pinch will handle)
      if (activePointers.size <= 1) {
        canvas.setPointerCapture(e.pointerId);
      }
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

      if (activePointers.size === 1) {
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY };
        translateStart = { ...translate };
        canvas.classList.add('grabbing');
      } else if (activePointers.size === 2) {
        // Initialize pinch
        pinchInitial = computePinchState();
        isPanning = false; // pinch takes over
      }
    });

    canvas.addEventListener('pointermove', (e)=>{
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

      if (activePointers.size === 2) {
        handlePinchGesture();
        return;
      }

      if (!isPanning) return;
      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;
      translate.x = translateStart.x + dx;
      translate.y = translateStart.y + dy;
      clampTranslate();
      setTransform();
    });

    function endPointer(e){
      if (!activePointers.has(e.pointerId)) return;
      activePointers.delete(e.pointerId);

      if (activePointers.size === 0) {
        isPanning = false;
        pinchInitial = null;
        canvas.classList.remove('grabbing');
      } else if (activePointers.size === 1) {
        // fall back to panning state after pinch ends
        const [only] = activePointers.values();
        panStart = { ...only };
        translateStart = { ...translate };
        isPanning = true;
      }
    }

    canvas.addEventListener('pointerup', endPointer);
    canvas.addEventListener('pointercancel', endPointer);

    function computePinchState(){
      const pts = Array.from(activePointers.values());
      if (pts.length < 2) return null;
      const [a,b] = pts;
      const dx = b.x - a.x, dy = b.y - a.y;
      const distance = Math.hypot(dx, dy);
      const center = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
      return { distance, center, zoomIndex };
    }

    function handlePinchGesture(){
      const now = computePinchState();
      if (!now || !pinchInitial) return;

      // Pinch delta in native CSS scale units
      const delta = now.distance / pinchInitial.distance;
      const desiredTotalScale = baseScale * ZOOM_LEVELS[pinchInitial.zoomIndex] * delta;

      // Snap to closest allowed zoom level
      let closestIdx = 0;
      let closestDiff = Infinity;
      for (let i=0;i<ZOOM_LEVELS.length;i++){
        const diff = Math.abs(baseScale * ZOOM_LEVELS[i] - desiredTotalScale);
        if (diff < closestDiff) { closestDiff = diff; closestIdx = i; }
      }

      if (closestIdx !== zoomIndex) {
        // Preserve the view center while zooming
        setZoomIndex(closestIdx);
      }

      // clamp & apply
      clampTranslate();
      setTransform();
    }

    // Recompute base scale & keep view center on resize/orientation changes
    let resizeRaf = null;
    window.addEventListener('resize', ()=>{
      if (resizeRaf) cancelAnimationFrame(resizeRaf);
      resizeRaf = requestAnimationFrame(()=>{
        const vp = viewport();
        const oldScale = currentScale();
        const center = { x: vp.w/2, y: vp.h/2 };
        const imagePoint = {
          x: (center.x - translate.x) / oldScale,
          y: (center.y - translate.y) / oldScale,
        };
        computeBaseScale();
        const newScale = currentScale();
        translate.x = center.x - imagePoint.x * newScale;
        translate.y = center.y - imagePoint.y * newScale;
        clampTranslate();
        switchAssetIfNeeded();
        setTransform();
      });
    });

    /*** BOOT ***/
    (async function boot(){
      // Decode 1x to read natural size
      const boot = new Image();
      boot.decoding = 'async';
      boot.src = assetUrl('1x');
      await boot.decode();

      baseWidth  = boot.naturalWidth;   // 1024
      baseHeight = boot.naturalHeight;  // 768

      // Lock initial logical size on the wrapper
      layer.style.width  = baseWidth + 'px';
      layer.style.height = baseHeight + 'px';

      // Show the boot image immediately
      img.src = boot.src;

      computeBaseScale();
      switchAssetIfNeeded();

      // Start fully-fit view centered
      clampTranslate();
      setTransform();
      updateButtons();

      // Preload adjacent zoom assets for snappy first interaction
      ensurePreloaded(assetKeyFor(1));
    })();
  })();
  </script>
</body>
</html>
